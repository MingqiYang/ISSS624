---
title: "Take-home Exercise 2: Regionalisation of Multivariate Water Point Attributes with Non-spatially Constrained and Spatially Constrained Clustering Methods"
editor: visual
date: "`r Sys.Date()`"
execute: 
  warning: false
  message: false
---

## 1 Overview

The process of creating regions is called [regionalisation](https://www.researchgate.net/publication/28153673_Supervised_Regionalization_Methods_A_Survey/link/0fcfd5094046b13d35000000/download). A regionalisation is a special kind of clustering where the objective is to group observations which are similar in their statistical attributes, but also in their spatial location. In this sense, regionalization embeds the same logic as standard clustering techniques, but also applies a series of geographical constraints. Often, these constraints relate to connectivity: two candidates can only be grouped together in the same region if there exists a path from one member to another member that never leaves the region. These paths often model the spatial relationships in the data, such as contiguity or proximity. However, connectivity does not always need to hold for all regions, and in certain contexts it makes sense to relax connectivity or to impose different types of geographic constraints.

In this take-home exercise we will regionalise Nigeria by using, but not limited to the following measures:

-   Total number of functional water points

-   Total number of nonfunctional water points

-   Percentage of functional water points

-   Percentage of non-functional water points

-   Percentage of main water point technology (i.e. Hand Pump)

-   Percentage of usage capacity (i.e. \< 1000, \>=1000)

-   Percentage of rural water points

## 2 Getting Started

Before we get started, it is important for us to install the necessary R packages into R and launch these R packages into R environment.

The R packages needed for this exercise are as follows:

-   Spatial data handling

    -   **sf**, **rgdal** and **spdep**

-   Attribute data handling

    -   **tidyverse**, especially **readr**, **ggplot2** and **dplyr**

-   Choropleth mapping

    -   **tmap**

-   Multivariate data visualisation and analysis

    -   **coorplot**, **ggpubr**, and **heatmaply**

-   Cluster analysis

    -   **cluster**

    -   **ClustGeo**

The code chunks below installs and launches these R packages into R environment.

```{r}
pacman::p_load(rgdal, spdep, tmap, sf, ClustGeo, funModeling,
               ggpubr, cluster, factoextra, NbClust,
               heatmaply, corrplot, psych, tidyverse, GGally)
```

Note: With **tidyverse**, we do not have to install **readr**, **ggplot2** and **dplyr** packages separately. In fact, **tidyverse** also installs other very useful R packages such as **tidyr**.

## 3 Data Preparation

**Aspatial data**

For the purpose of this assignment, data from [WPdx Global Data Repositories](https://www.waterpointdata.org/access-data/) will be used. There are two versions of the data. They are: WPdx-Basic and WPdx+. You are required to use WPdx+ data set.

**Geospatial data**

Nigeria Level-2 Administrative Boundary (also known as Local Government Area) polygon features GIS data will be used in this take-home exercise. The data can be downloaded either from The [Humanitarian Data Exchange](https://data.humdata.org/) portal or [geoBoundaries](https://www.geoboundaries.org/).

### 3.1 Importing data

#### 3.1.1 Importing aspatial data

As the data is in csv format, we will use the ***read_csv()*** function of readr package to import the WPdx CSV file, then extract only Nigeria data from the CSV using the ***filter()*** function of dplyr package:

```{r eval=FALSE,echo=TRUE}
wp_nga <- read_csv("data/aspatial/Water_Point_Data_Exchange_-_Plus__WPdx__.csv") %>%
  filter(`#clean_country_name` == "Nigeria")
```

```{r eval=FALSE,echo=TRUE}
wp_nga <- st_as_sf(wp_nga, 
                   coords = c("#lat_deg", "#lon_deg"),
                   crs=4326) %>%
  st_transform(crs = 26391)
```

#### 3.1.2 Importing geospatial data

Then we will use ***st_read()*** function of sf package to import geoBoundaries-NGA-ADM2 shapefile into R environment.

```{r eval=FALSE,echo=TRUE}
nga <- st_read(dsn = "data/geospatial",
               layer = "geoBoundaries-NGA-ADM2",
               crs = 4326) %>%
  select(shapeName) %>%
  st_transform(crs = 26391)
```

### 3.2 Data wrangling

#### 3.2.1 Duplicated shapeName renaming

When we sort the nga dataframe by alphabetical order, we find out that there are 12 duplicated shapeName values.

-   ***duplicated()*** function returns a logical vector where TRUE specifies which elements of a vector or data frame are duplicates.

-   ***filter()*** function filters those duplicates and lets check what are the duplicated shape Names

```{r eval=FALSE,echo=TRUE}
duplicated_area <- nga %>% 
  mutate(duplicated_shapeName = duplicated(shapeName)) %>% 
  filter(duplicated_shapeName)
duplicated_area$shapeName
```

Then we rename these duplicated shapeName:

```{r eval=FALSE,echo=TRUE}
nga$shapeName[c(94,95,304,305,355,356,519,546,547,693,694)] <- 
  c("Bassa (Kogi)","Bassa (Plateau)","Ifelodun (Kwara)","Ifelodun (Osun)","Irepodun (Kwara)","Irepodun (Osun)","Nassarawa","Obi (Benue)","Obi(Nasarawa)","Surulere (Lagos)","Surulere (Oyo)")
```

After renaming these values, we check the uniqueness again:

```{r eval=FALSE,echo=TRUE}
length(unique(nga$shapeName))
```

The result is 774 which shows no duplication.

#### 3.3.2 Aspatial data cleaning

We will rename some column names using the ***rename()*** function from dyplr and replace the NA values with Unknown and 0 using the ***mutate()*** function.

```{r eval=FALSE,echo=TRUE}
wp_nga <- wp_nga  %>%
  rename ("status_clean" = "#status_clean",
          "status_id" = "#status_id",
          "water_tech" = "#water_tech_category") %>%
  mutate(status_clean = replace_na(status_clean, "Unknown")) %>%
  mutate (water_tech = replace_na(water_tech, "Unknown")) %>%
  mutate(water_point_population = replace_na(water_point_population,0))
```

#### 3.3.3 Data combining - Point-in-Polygon Overlay

We will use the ***st_join()*** function from the sf package to transfer the attribute information in nga data frame into wp_nga data frame.

```{r eval=FALSE,echo=TRUE}
nga_wp_sf <- st_join(wp_nga, nga)
```

### 3.3 EDA

We will use ***freq()*** function from funModelling package to visualise different attributes of water points.

#### 3.3.1 status_clean

```{r eval=FALSE,echo=TRUE}
freq(data=nga_wp_sf, 
     input = 'status_clean')
```

#### 3.3.2 water_tech

```{r eval=FALSE,echo=TRUE}
freq(data = nga_wp_sf, 
     input = "water_tech")
```

#### 3.3.3 usage_capacity

```{r eval=FALSE,echo=TRUE}
freq(data = nga_wp_sf, 
     input = "usage_capacity")
```

#### 3.3.4 is_urban

```{r eval=FALSE,echo=TRUE}
freq(data = nga_wp_sf, 
     input = "is_urban")
```

### 3.4 Variables Extraction

#### 3.4.1 Functionality

Functional water points:

```{r eval=FALSE,echo=TRUE}
wp_functional <- nga_wp_sf %>%
  filter(`status_clean` %in% c("Functional", 
                               "Functional but not in use",
                               "Functional but needs repair"))
```

Non-functional water points:

```{r eval=FALSE,echo=TRUE}
wp_nonfunctional <- nga_wp_sf %>%
  filter(`status_clean` %in% c("Non-Functional", 
                                "Non-Functional due to dry season",
                                "Non functional due to dry season",
                                "Abandoned/Decommissioned",
                                "Abandoned"))
```

#### 3.4.2 Water point technology

Hand Pump water points:

```{r eval=FALSE,echo=TRUE}
wp_handpump <- nga_wp_sf %>%
  filter(`water_tech` == "Hand Pump")
```

Mechanized Pump water points:

```{r eval=FALSE,echo=TRUE}
wp_mechpump <- nga_wp_sf %>%
  filter(`water_tech` == "Mechanized Pump")
```

#### 3.4.3 Usage capacity

usage_capacity \< 1000:

```{r eval=FALSE,echo=TRUE}
wp_less_than_1000 <- nga_wp_sf %>%
  filter(`usage_capacity` < 1000)
```

usage_capacity\>= 1000:

```{r eval=FALSE,echo=TRUE}
wp_more_than_1000 <- nga_wp_sf %>%
  filter(`usage_capacity` >= 1000)
```

#### 3.4.4 Rural or urban

Rural:

```{r eval=FALSE,echo=TRUE}
wp_rural <- nga_wp_sf %>%
  filter(`is_urban` == FALSE)
```

Urban:

```{r eval=FALSE,echo=TRUE}
wp_urban <- nga_wp_sf %>%
  filter(`is_urban` == TRUE)
```

### 3.5 Performing Point-in-Polygon Count

We will count the water points with the above variables in each LGA, and calculate proportion:

```{r eval=FALSE,echo=TRUE}
wp_nga_final <- nga %>% 
  mutate(total_num = lengths(
    st_intersects(nga, nga_wp_sf))) %>%
  mutate(functional_num = lengths(
    st_intersects(nga, wp_functional))) %>%
  mutate(nonfunctional_num = lengths(
    st_intersects(nga, wp_nonfunctional))) %>%
  mutate(handpump_num = lengths(
    st_intersects(nga, wp_handpump))) %>%
  mutate(mechpump_num = lengths(
    st_intersects(nga, wp_mechpump))) %>%
  mutate(caplessthan1000_num = lengths(
    st_intersects(nga, wp_less_than_1000))) %>%
  mutate(capmorethan1000_num = lengths(
    st_intersects(nga, wp_more_than_1000))) %>%
  mutate(rural_num = lengths(
    st_intersects(nga, wp_rural))) %>%
  mutate(urban_num = lengths(
    st_intersects(nga, wp_urban))) %>%
  mutate(functional_pct = functional_num/total_num) %>%
  mutate(nonfunctional_pct = nonfunctional_num/total_num) %>%
  mutate(handpump_pct = handpump_num/total_num) %>%
  mutate(mechpump_pct = mechpump_num/total_num) %>%
  mutate(caplessthan1000_pct = caplessthan1000_num/total_num) %>%
  mutate(capmorethan1000_pct = capmorethan1000_num/total_num) %>%
  mutate(rural_pct = rural_num/total_num) %>%
  mutate(urban_pct = urban_num/total_num) 
```

### 3.6 Saving data table

We will save the final analytical data table in rds format.

```{r eval=FALSE,echo=TRUE}
write_rds(wp_nga_final, "data/wp_nga_final.rds")
```

## 4 Mapping

At first, we will need to read and load the data saved previously into wp_nigeria variable for use in subsequent clustering analysis:

```{r}
wp_nga_final <- read_rds("data/wp_nga_final.rds")
```

```{r}
summary(wp_nga_final)
```

4.1

```{r}

```
